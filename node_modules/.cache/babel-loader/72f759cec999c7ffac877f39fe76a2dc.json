{"ast":null,"code":"'use strict';\n\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = (fn, {\n  cacheKey,\n  cache = new Map(),\n  maxAge\n} = {}) => {\n  if (typeof maxAge === 'number') {\n    // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n    // @ts-expect-error\n    mapAgeCleaner(cache);\n  }\n  const memoized = function (...arguments_) {\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = cache.get(key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n    const result = fn.apply(this, arguments_);\n    cache.set(key, {\n      data: result,\n      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n    });\n    return result;\n  };\n  mimicFn(memoized, fn, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n  const input = target[propertyKey];\n  if (typeof input !== 'function') {\n    throw new TypeError('The decorated value must be a function');\n  }\n  delete descriptor.value;\n  delete descriptor.writable;\n  descriptor.get = function () {\n    if (!decoratorInstanceMap.has(this)) {\n      const value = mem(input, options);\n      decoratorInstanceMap.set(this, value);\n      return value;\n    }\n    return decoratorInstanceMap.get(this);\n  };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = fn => {\n  const cache = cacheStore.get(fn);\n  if (!cache) {\n    throw new TypeError('Can\\'t clear a function that was not memoized!');\n  }\n  if (typeof cache.clear !== 'function') {\n    throw new TypeError('The cache Map can\\'t be cleared!');\n  }\n  cache.clear();\n};\nmodule.exports = mem;","map":null,"metadata":{},"sourceType":"script"}