{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n  let processingKey;\n  let processingTimer;\n  let processingDeferred;\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n    if (processingKey !== undefined) {\n      // If we are already processing an item, we can safely exit\n      return;\n    }\n    const setupTimer = item => __awaiter(this, void 0, void 0, function* () {\n      processingDeferred = p_defer_1.default();\n      const delay = item[1][property] - Date.now();\n      if (delay <= 0) {\n        // Remove the item immediately if the delay is equal to or below 0\n        map.delete(item[0]);\n        processingDeferred.resolve();\n        return;\n      }\n      // Keep track of the current processed key\n      processingKey = item[0];\n      processingTimer = setTimeout(() => {\n        // Remove the item when the timeout fires\n        map.delete(item[0]);\n        if (processingDeferred) {\n          processingDeferred.resolve();\n        }\n      }, delay);\n      // tslint:disable-next-line:strict-type-predicates\n      if (typeof processingTimer.unref === 'function') {\n        // Don't hold up the process from exiting\n        processingTimer.unref();\n      }\n      return processingDeferred.promise;\n    });\n    try {\n      for (const entry of map) {\n        yield setupTimer(entry);\n      }\n    } catch (_a) {\n      // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n    }\n    processingKey = undefined;\n  });\n  const reset = () => {\n    processingKey = undefined;\n    if (processingTimer !== undefined) {\n      clearTimeout(processingTimer);\n      processingTimer = undefined;\n    }\n    if (processingDeferred !== undefined) {\n      // tslint:disable-line:early-exit\n      processingDeferred.reject(undefined);\n      processingDeferred = undefined;\n    }\n  };\n  const originalSet = map.set.bind(map);\n  map.set = (key, value) => {\n    if (map.has(key)) {\n      // If the key already exist, remove it so we can add it back at the end of the map.\n      map.delete(key);\n    }\n    // Call the original `map.set`\n    const result = originalSet(key, value);\n    // If we are already processing a key and the key added is the current processed key, stop processing it\n    if (processingKey && processingKey === key) {\n      reset();\n    }\n    // Always run the cleanup method in case it wasn't started yet\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return result;\n  };\n  cleanup(); // tslint:disable-line:no-floating-promises\n  return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;","map":null,"metadata":{},"sourceType":"script"}